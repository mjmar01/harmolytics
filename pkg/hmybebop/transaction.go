// Code generated by bebopc-go; DO NOT EDIT.

package hmybebop

import (
	"github.com/200sc/bebop"
	"github.com/200sc/bebop/iohelp"
	"io"
)

var _ bebop.Record = &Transaction{}

type Transaction struct {
	Hash      []byte
	EthHash   []byte
	Sender    []byte
	Receiver  []byte
	BlockNum  uint32
	TimeStamp uint64
	Amount    []byte
	Input     []byte
	Logs      []Log
	Status    byte
	GasAmount uint32
	GasPrice  []byte
	Shard     byte
	ToShard   byte
}

func (bbp Transaction) MarshalBebopTo(buf []byte) int {
	at := 0
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.Hash)))
	at += 4
	copy(buf[at:at+len(bbp.Hash)], bbp.Hash)
	at += len(bbp.Hash)
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.EthHash)))
	at += 4
	copy(buf[at:at+len(bbp.EthHash)], bbp.EthHash)
	at += len(bbp.EthHash)
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.Sender)))
	at += 4
	copy(buf[at:at+len(bbp.Sender)], bbp.Sender)
	at += len(bbp.Sender)
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.Receiver)))
	at += 4
	copy(buf[at:at+len(bbp.Receiver)], bbp.Receiver)
	at += len(bbp.Receiver)
	iohelp.WriteUint32Bytes(buf[at:], bbp.BlockNum)
	at += 4
	iohelp.WriteUint64Bytes(buf[at:], bbp.TimeStamp)
	at += 8
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.Amount)))
	at += 4
	copy(buf[at:at+len(bbp.Amount)], bbp.Amount)
	at += len(bbp.Amount)
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.Input)))
	at += 4
	copy(buf[at:at+len(bbp.Input)], bbp.Input)
	at += len(bbp.Input)
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.Logs)))
	at += 4
	for _, v1 := range bbp.Logs {
		(v1).MarshalBebopTo(buf[at:])
		at += (v1).Size()
	}
	iohelp.WriteByteBytes(buf[at:], bbp.Status)
	at += 1
	iohelp.WriteUint32Bytes(buf[at:], bbp.GasAmount)
	at += 4
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.GasPrice)))
	at += 4
	copy(buf[at:at+len(bbp.GasPrice)], bbp.GasPrice)
	at += len(bbp.GasPrice)
	iohelp.WriteByteBytes(buf[at:], bbp.Shard)
	at += 1
	iohelp.WriteByteBytes(buf[at:], bbp.ToShard)
	at += 1
	return at
}

func (bbp *Transaction) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.Hash = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.Hash)*1 {
		return io.ErrUnexpectedEOF
	}
	copy(bbp.Hash, buf[at:at+len(bbp.Hash)])
	at += len(bbp.Hash)
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.EthHash = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.EthHash)*1 {
		return io.ErrUnexpectedEOF
	}
	copy(bbp.EthHash, buf[at:at+len(bbp.EthHash)])
	at += len(bbp.EthHash)
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.Sender = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.Sender)*1 {
		return io.ErrUnexpectedEOF
	}
	copy(bbp.Sender, buf[at:at+len(bbp.Sender)])
	at += len(bbp.Sender)
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.Receiver = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.Receiver)*1 {
		return io.ErrUnexpectedEOF
	}
	copy(bbp.Receiver, buf[at:at+len(bbp.Receiver)])
	at += len(bbp.Receiver)
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.BlockNum = iohelp.ReadUint32Bytes(buf[at:])
	at += 4
	if len(buf[at:]) < 8 {
		return io.ErrUnexpectedEOF
	}
	bbp.TimeStamp = iohelp.ReadUint64Bytes(buf[at:])
	at += 8
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.Amount = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.Amount)*1 {
		return io.ErrUnexpectedEOF
	}
	copy(bbp.Amount, buf[at:at+len(bbp.Amount)])
	at += len(bbp.Amount)
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.Input = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.Input)*1 {
		return io.ErrUnexpectedEOF
	}
	copy(bbp.Input, buf[at:at+len(bbp.Input)])
	at += len(bbp.Input)
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.Logs = make([]Log, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.Logs {
		(bbp.Logs)[i1], err = MakeLogFromBytes(buf[at:])
		if err != nil {
			return err
		}
		at += ((bbp.Logs)[i1]).Size()
	}
	if len(buf[at:]) < 1 {
		return io.ErrUnexpectedEOF
	}
	bbp.Status = iohelp.ReadByteBytes(buf[at:])
	at += 1
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.GasAmount = iohelp.ReadUint32Bytes(buf[at:])
	at += 4
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.GasPrice = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.GasPrice)*1 {
		return io.ErrUnexpectedEOF
	}
	copy(bbp.GasPrice, buf[at:at+len(bbp.GasPrice)])
	at += len(bbp.GasPrice)
	if len(buf[at:]) < 1 {
		return io.ErrUnexpectedEOF
	}
	bbp.Shard = iohelp.ReadByteBytes(buf[at:])
	at += 1
	if len(buf[at:]) < 1 {
		return io.ErrUnexpectedEOF
	}
	bbp.ToShard = iohelp.ReadByteBytes(buf[at:])
	at += 1
	return nil
}

func (bbp Transaction) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(len(bbp.Hash)))
	for _, elem := range bbp.Hash {
		iohelp.WriteByte(w, elem)
	}
	iohelp.WriteUint32(w, uint32(len(bbp.EthHash)))
	for _, elem := range bbp.EthHash {
		iohelp.WriteByte(w, elem)
	}
	iohelp.WriteUint32(w, uint32(len(bbp.Sender)))
	for _, elem := range bbp.Sender {
		iohelp.WriteByte(w, elem)
	}
	iohelp.WriteUint32(w, uint32(len(bbp.Receiver)))
	for _, elem := range bbp.Receiver {
		iohelp.WriteByte(w, elem)
	}
	iohelp.WriteUint32(w, bbp.BlockNum)
	iohelp.WriteUint64(w, bbp.TimeStamp)
	iohelp.WriteUint32(w, uint32(len(bbp.Amount)))
	for _, elem := range bbp.Amount {
		iohelp.WriteByte(w, elem)
	}
	iohelp.WriteUint32(w, uint32(len(bbp.Input)))
	for _, elem := range bbp.Input {
		iohelp.WriteByte(w, elem)
	}
	iohelp.WriteUint32(w, uint32(len(bbp.Logs)))
	for _, elem := range bbp.Logs {
		err = (elem).EncodeBebop(w)
		if err != nil {
			return err
		}
	}
	iohelp.WriteByte(w, bbp.Status)
	iohelp.WriteUint32(w, bbp.GasAmount)
	iohelp.WriteUint32(w, uint32(len(bbp.GasPrice)))
	for _, elem := range bbp.GasPrice {
		iohelp.WriteByte(w, elem)
	}
	iohelp.WriteByte(w, bbp.Shard)
	iohelp.WriteByte(w, bbp.ToShard)
	return w.Err
}

func (bbp *Transaction) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.Hash = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.Hash {
		(bbp.Hash[i1]) = iohelp.ReadByte(r)
	}
	bbp.EthHash = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.EthHash {
		(bbp.EthHash[i1]) = iohelp.ReadByte(r)
	}
	bbp.Sender = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.Sender {
		(bbp.Sender[i1]) = iohelp.ReadByte(r)
	}
	bbp.Receiver = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.Receiver {
		(bbp.Receiver[i1]) = iohelp.ReadByte(r)
	}
	bbp.BlockNum = iohelp.ReadUint32(r)
	bbp.TimeStamp = iohelp.ReadUint64(r)
	bbp.Amount = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.Amount {
		(bbp.Amount[i1]) = iohelp.ReadByte(r)
	}
	bbp.Input = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.Input {
		(bbp.Input[i1]) = iohelp.ReadByte(r)
	}
	bbp.Logs = make([]Log, iohelp.ReadUint32(r))
	for i1 := range bbp.Logs {
		(bbp.Logs[i1]), err = MakeLog(r)
		if err != nil {
			return err
		}
	}
	bbp.Status = iohelp.ReadByte(r)
	bbp.GasAmount = iohelp.ReadUint32(r)
	bbp.GasPrice = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.GasPrice {
		(bbp.GasPrice[i1]) = iohelp.ReadByte(r)
	}
	bbp.Shard = iohelp.ReadByte(r)
	bbp.ToShard = iohelp.ReadByte(r)
	return r.Err
}

func (bbp Transaction) Size() int {
	bodyLen := 0
	bodyLen += 4
	bodyLen += len(bbp.Hash) * 1
	bodyLen += 4
	bodyLen += len(bbp.EthHash) * 1
	bodyLen += 4
	bodyLen += len(bbp.Sender) * 1
	bodyLen += 4
	bodyLen += len(bbp.Receiver) * 1
	bodyLen += 4
	bodyLen += 8
	bodyLen += 4
	bodyLen += len(bbp.Amount) * 1
	bodyLen += 4
	bodyLen += len(bbp.Input) * 1
	bodyLen += 4
	for _, elem := range bbp.Logs {
		bodyLen += (elem).Size()
	}
	bodyLen += 1
	bodyLen += 4
	bodyLen += 4
	bodyLen += len(bbp.GasPrice) * 1
	bodyLen += 1
	bodyLen += 1
	return bodyLen
}

func (bbp Transaction) MarshalBebop() []byte {
	buf := make([]byte, bbp.Size())
	bbp.MarshalBebopTo(buf)
	return buf
}

func MakeTransaction(r iohelp.ErrorReader) (Transaction, error) {
	v := Transaction{}
	err := v.DecodeBebop(r)
	return v, err
}

func MakeTransactionFromBytes(buf []byte) (Transaction, error) {
	v := Transaction{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

var _ bebop.Record = &Log{}

type Log struct {
	Index   uint16
	Address []byte
	Topics  []byte
	Data    []byte
}

func (bbp Log) MarshalBebopTo(buf []byte) int {
	at := 0
	iohelp.WriteUint16Bytes(buf[at:], bbp.Index)
	at += 2
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.Address)))
	at += 4
	copy(buf[at:at+len(bbp.Address)], bbp.Address)
	at += len(bbp.Address)
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.Topics)))
	at += 4
	copy(buf[at:at+len(bbp.Topics)], bbp.Topics)
	at += len(bbp.Topics)
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.Data)))
	at += 4
	copy(buf[at:at+len(bbp.Data)], bbp.Data)
	at += len(bbp.Data)
	return at
}

func (bbp *Log) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	if len(buf[at:]) < 2 {
		return io.ErrUnexpectedEOF
	}
	bbp.Index = iohelp.ReadUint16Bytes(buf[at:])
	at += 2
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.Address = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.Address)*1 {
		return io.ErrUnexpectedEOF
	}
	copy(bbp.Address, buf[at:at+len(bbp.Address)])
	at += len(bbp.Address)
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.Topics = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.Topics)*1 {
		return io.ErrUnexpectedEOF
	}
	copy(bbp.Topics, buf[at:at+len(bbp.Topics)])
	at += len(bbp.Topics)
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.Data = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.Data)*1 {
		return io.ErrUnexpectedEOF
	}
	copy(bbp.Data, buf[at:at+len(bbp.Data)])
	at += len(bbp.Data)
	return nil
}

func (bbp Log) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint16(w, bbp.Index)
	iohelp.WriteUint32(w, uint32(len(bbp.Address)))
	for _, elem := range bbp.Address {
		iohelp.WriteByte(w, elem)
	}
	iohelp.WriteUint32(w, uint32(len(bbp.Topics)))
	for _, elem := range bbp.Topics {
		iohelp.WriteByte(w, elem)
	}
	iohelp.WriteUint32(w, uint32(len(bbp.Data)))
	for _, elem := range bbp.Data {
		iohelp.WriteByte(w, elem)
	}
	return w.Err
}

func (bbp *Log) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.Index = iohelp.ReadUint16(r)
	bbp.Address = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.Address {
		(bbp.Address[i1]) = iohelp.ReadByte(r)
	}
	bbp.Topics = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.Topics {
		(bbp.Topics[i1]) = iohelp.ReadByte(r)
	}
	bbp.Data = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.Data {
		(bbp.Data[i1]) = iohelp.ReadByte(r)
	}
	return r.Err
}

func (bbp Log) Size() int {
	bodyLen := 0
	bodyLen += 2
	bodyLen += 4
	bodyLen += len(bbp.Address) * 1
	bodyLen += 4
	bodyLen += len(bbp.Topics) * 1
	bodyLen += 4
	bodyLen += len(bbp.Data) * 1
	return bodyLen
}

func (bbp Log) MarshalBebop() []byte {
	buf := make([]byte, bbp.Size())
	bbp.MarshalBebopTo(buf)
	return buf
}

func MakeLog(r iohelp.ErrorReader) (Log, error) {
	v := Log{}
	err := v.DecodeBebop(r)
	return v, err
}

func MakeLogFromBytes(buf []byte) (Log, error) {
	v := Log{}
	err := v.UnmarshalBebop(buf)
	return v, err
}
