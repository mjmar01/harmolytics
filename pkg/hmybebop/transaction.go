// Code generated by bebopc-go; DO NOT EDIT.

package hmybebop

import (
	"github.com/200sc/bebop"
	"github.com/200sc/bebop/iohelp"
	"io"
)

var _ bebop.Record = &transaction{}

type transaction struct {
	hash      []byte
	ethHash   []byte
	sender    addr
	receiver  addr
	blockNum  uint32
	timeStamp uint64
	amount    []byte
	input     []byte
	method    method
	logs      []log
	status    byte
	gasAmount uint32
	gasPrice  []byte
	shard     byte
	toShard   byte
}

func (bbp transaction) MarshalBebopTo(buf []byte) int {
	at := 0
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.hash)))
	at += 4
	copy(buf[at:at+len(bbp.hash)], bbp.hash)
	at += len(bbp.hash)
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.ethHash)))
	at += 4
	copy(buf[at:at+len(bbp.ethHash)], bbp.ethHash)
	at += len(bbp.ethHash)
	(bbp.sender).MarshalBebopTo(buf[at:])
	at += (bbp.sender).Size()
	(bbp.receiver).MarshalBebopTo(buf[at:])
	at += (bbp.receiver).Size()
	iohelp.WriteUint32Bytes(buf[at:], bbp.blockNum)
	at += 4
	iohelp.WriteUint64Bytes(buf[at:], bbp.timeStamp)
	at += 8
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.amount)))
	at += 4
	copy(buf[at:at+len(bbp.amount)], bbp.amount)
	at += len(bbp.amount)
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.input)))
	at += 4
	copy(buf[at:at+len(bbp.input)], bbp.input)
	at += len(bbp.input)
	(bbp.method).MarshalBebopTo(buf[at:])
	at += (bbp.method).Size()
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.logs)))
	at += 4
	for _, v1 := range bbp.logs {
		(v1).MarshalBebopTo(buf[at:])
		at += (v1).Size()
	}
	iohelp.WriteByteBytes(buf[at:], bbp.status)
	at += 1
	iohelp.WriteUint32Bytes(buf[at:], bbp.gasAmount)
	at += 4
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.gasPrice)))
	at += 4
	copy(buf[at:at+len(bbp.gasPrice)], bbp.gasPrice)
	at += len(bbp.gasPrice)
	iohelp.WriteByteBytes(buf[at:], bbp.shard)
	at += 1
	iohelp.WriteByteBytes(buf[at:], bbp.toShard)
	at += 1
	return at
}

func (bbp *transaction) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.hash = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.hash)*1 {
		return io.ErrUnexpectedEOF
	}
	copy(bbp.hash, buf[at:at+len(bbp.hash)])
	at += len(bbp.hash)
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.ethHash = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.ethHash)*1 {
		return io.ErrUnexpectedEOF
	}
	copy(bbp.ethHash, buf[at:at+len(bbp.ethHash)])
	at += len(bbp.ethHash)
	bbp.sender, err = makeaddrFromBytes(buf[at:])
	if err != nil {
		return err
	}
	at += (bbp.sender).Size()
	bbp.receiver, err = makeaddrFromBytes(buf[at:])
	if err != nil {
		return err
	}
	at += (bbp.receiver).Size()
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.blockNum = iohelp.ReadUint32Bytes(buf[at:])
	at += 4
	if len(buf[at:]) < 8 {
		return io.ErrUnexpectedEOF
	}
	bbp.timeStamp = iohelp.ReadUint64Bytes(buf[at:])
	at += 8
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.amount = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.amount)*1 {
		return io.ErrUnexpectedEOF
	}
	copy(bbp.amount, buf[at:at+len(bbp.amount)])
	at += len(bbp.amount)
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.input = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.input)*1 {
		return io.ErrUnexpectedEOF
	}
	copy(bbp.input, buf[at:at+len(bbp.input)])
	at += len(bbp.input)
	bbp.method, err = makemethodFromBytes(buf[at:])
	if err != nil {
		return err
	}
	at += (bbp.method).Size()
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.logs = make([]log, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.logs {
		(bbp.logs)[i1], err = makelogFromBytes(buf[at:])
		if err != nil {
			return err
		}
		at += ((bbp.logs)[i1]).Size()
	}
	if len(buf[at:]) < 1 {
		return io.ErrUnexpectedEOF
	}
	bbp.status = iohelp.ReadByteBytes(buf[at:])
	at += 1
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.gasAmount = iohelp.ReadUint32Bytes(buf[at:])
	at += 4
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.gasPrice = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.gasPrice)*1 {
		return io.ErrUnexpectedEOF
	}
	copy(bbp.gasPrice, buf[at:at+len(bbp.gasPrice)])
	at += len(bbp.gasPrice)
	if len(buf[at:]) < 1 {
		return io.ErrUnexpectedEOF
	}
	bbp.shard = iohelp.ReadByteBytes(buf[at:])
	at += 1
	if len(buf[at:]) < 1 {
		return io.ErrUnexpectedEOF
	}
	bbp.toShard = iohelp.ReadByteBytes(buf[at:])
	at += 1
	return nil
}

func (bbp transaction) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(len(bbp.hash)))
	for _, elem := range bbp.hash {
		iohelp.WriteByte(w, elem)
	}
	iohelp.WriteUint32(w, uint32(len(bbp.ethHash)))
	for _, elem := range bbp.ethHash {
		iohelp.WriteByte(w, elem)
	}
	err = (bbp.sender).EncodeBebop(w)
	if err != nil {
		return err
	}
	err = (bbp.receiver).EncodeBebop(w)
	if err != nil {
		return err
	}
	iohelp.WriteUint32(w, bbp.blockNum)
	iohelp.WriteUint64(w, bbp.timeStamp)
	iohelp.WriteUint32(w, uint32(len(bbp.amount)))
	for _, elem := range bbp.amount {
		iohelp.WriteByte(w, elem)
	}
	iohelp.WriteUint32(w, uint32(len(bbp.input)))
	for _, elem := range bbp.input {
		iohelp.WriteByte(w, elem)
	}
	err = (bbp.method).EncodeBebop(w)
	if err != nil {
		return err
	}
	iohelp.WriteUint32(w, uint32(len(bbp.logs)))
	for _, elem := range bbp.logs {
		err = (elem).EncodeBebop(w)
		if err != nil {
			return err
		}
	}
	iohelp.WriteByte(w, bbp.status)
	iohelp.WriteUint32(w, bbp.gasAmount)
	iohelp.WriteUint32(w, uint32(len(bbp.gasPrice)))
	for _, elem := range bbp.gasPrice {
		iohelp.WriteByte(w, elem)
	}
	iohelp.WriteByte(w, bbp.shard)
	iohelp.WriteByte(w, bbp.toShard)
	return w.Err
}

func (bbp *transaction) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.hash = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.hash {
		(bbp.hash[i1]) = iohelp.ReadByte(r)
	}
	bbp.ethHash = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.ethHash {
		(bbp.ethHash[i1]) = iohelp.ReadByte(r)
	}
	(bbp.sender), err = makeaddr(r)
	if err != nil {
		return err
	}
	(bbp.receiver), err = makeaddr(r)
	if err != nil {
		return err
	}
	bbp.blockNum = iohelp.ReadUint32(r)
	bbp.timeStamp = iohelp.ReadUint64(r)
	bbp.amount = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.amount {
		(bbp.amount[i1]) = iohelp.ReadByte(r)
	}
	bbp.input = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.input {
		(bbp.input[i1]) = iohelp.ReadByte(r)
	}
	(bbp.method), err = makemethod(r)
	if err != nil {
		return err
	}
	bbp.logs = make([]log, iohelp.ReadUint32(r))
	for i1 := range bbp.logs {
		(bbp.logs[i1]), err = makelog(r)
		if err != nil {
			return err
		}
	}
	bbp.status = iohelp.ReadByte(r)
	bbp.gasAmount = iohelp.ReadUint32(r)
	bbp.gasPrice = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.gasPrice {
		(bbp.gasPrice[i1]) = iohelp.ReadByte(r)
	}
	bbp.shard = iohelp.ReadByte(r)
	bbp.toShard = iohelp.ReadByte(r)
	return r.Err
}

func (bbp transaction) Size() int {
	bodyLen := 0
	bodyLen += 4
	bodyLen += len(bbp.hash) * 1
	bodyLen += 4
	bodyLen += len(bbp.ethHash) * 1
	bodyLen += (bbp.sender).Size()
	bodyLen += (bbp.receiver).Size()
	bodyLen += 4
	bodyLen += 8
	bodyLen += 4
	bodyLen += len(bbp.amount) * 1
	bodyLen += 4
	bodyLen += len(bbp.input) * 1
	bodyLen += (bbp.method).Size()
	bodyLen += 4
	for _, elem := range bbp.logs {
		bodyLen += (elem).Size()
	}
	bodyLen += 1
	bodyLen += 4
	bodyLen += 4
	bodyLen += len(bbp.gasPrice) * 1
	bodyLen += 1
	bodyLen += 1
	return bodyLen
}

func (bbp transaction) MarshalBebop() []byte {
	buf := make([]byte, bbp.Size())
	bbp.MarshalBebopTo(buf)
	return buf
}

func maketransaction(r iohelp.ErrorReader) (transaction, error) {
	v := transaction{}
	err := v.DecodeBebop(r)
	return v, err
}

func maketransactionFromBytes(buf []byte) (transaction, error) {
	v := transaction{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

var _ bebop.Record = &method{}

type method struct {
	signature string
	name      string
	params    []string
}

func (bbp method) MarshalBebopTo(buf []byte) int {
	at := 0
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.signature)))
	copy(buf[at+4:at+4+len(bbp.signature)], []byte(bbp.signature))
	at += 4 + len(bbp.signature)
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.name)))
	copy(buf[at+4:at+4+len(bbp.name)], []byte(bbp.name))
	at += 4 + len(bbp.name)
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.params)))
	at += 4
	for _, v1 := range bbp.params {
		iohelp.WriteUint32Bytes(buf[at:], uint32(len(v1)))
		copy(buf[at+4:at+4+len(v1)], []byte(v1))
		at += 4 + len(v1)
	}
	return at
}

func (bbp *method) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	bbp.signature, err = iohelp.ReadStringBytes(buf[at:])
	if err != nil {
		return err
	}
	at += 4 + len(bbp.signature)
	bbp.name, err = iohelp.ReadStringBytes(buf[at:])
	if err != nil {
		return err
	}
	at += 4 + len(bbp.name)
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.params = make([]string, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.params {
		(bbp.params)[i1], err = iohelp.ReadStringBytes(buf[at:])
		if err != nil {
			return err
		}
		at += 4 + len((bbp.params)[i1])
	}
	return nil
}

func (bbp method) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(len(bbp.signature)))
	w.Write([]byte(bbp.signature))
	iohelp.WriteUint32(w, uint32(len(bbp.name)))
	w.Write([]byte(bbp.name))
	iohelp.WriteUint32(w, uint32(len(bbp.params)))
	for _, elem := range bbp.params {
		iohelp.WriteUint32(w, uint32(len(elem)))
		w.Write([]byte(elem))
	}
	return w.Err
}

func (bbp *method) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.signature = iohelp.ReadString(r)
	bbp.name = iohelp.ReadString(r)
	bbp.params = make([]string, iohelp.ReadUint32(r))
	for i1 := range bbp.params {
		(bbp.params[i1]) = iohelp.ReadString(r)
	}
	return r.Err
}

func (bbp method) Size() int {
	bodyLen := 0
	bodyLen += 4 + len(bbp.signature)
	bodyLen += 4 + len(bbp.name)
	bodyLen += 4
	for _, elem := range bbp.params {
		bodyLen += 4 + len(elem)
	}
	return bodyLen
}

func (bbp method) MarshalBebop() []byte {
	buf := make([]byte, bbp.Size())
	bbp.MarshalBebopTo(buf)
	return buf
}

func makemethod(r iohelp.ErrorReader) (method, error) {
	v := method{}
	err := v.DecodeBebop(r)
	return v, err
}

func makemethodFromBytes(buf []byte) (method, error) {
	v := method{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

var _ bebop.Record = &addr{}

type addr struct {
	one string
	hex string
}

func (bbp addr) MarshalBebopTo(buf []byte) int {
	at := 0
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.one)))
	copy(buf[at+4:at+4+len(bbp.one)], []byte(bbp.one))
	at += 4 + len(bbp.one)
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.hex)))
	copy(buf[at+4:at+4+len(bbp.hex)], []byte(bbp.hex))
	at += 4 + len(bbp.hex)
	return at
}

func (bbp *addr) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	bbp.one, err = iohelp.ReadStringBytes(buf[at:])
	if err != nil {
		return err
	}
	at += 4 + len(bbp.one)
	bbp.hex, err = iohelp.ReadStringBytes(buf[at:])
	if err != nil {
		return err
	}
	at += 4 + len(bbp.hex)
	return nil
}

func (bbp addr) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(len(bbp.one)))
	w.Write([]byte(bbp.one))
	iohelp.WriteUint32(w, uint32(len(bbp.hex)))
	w.Write([]byte(bbp.hex))
	return w.Err
}

func (bbp *addr) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.one = iohelp.ReadString(r)
	bbp.hex = iohelp.ReadString(r)
	return r.Err
}

func (bbp addr) Size() int {
	bodyLen := 0
	bodyLen += 4 + len(bbp.one)
	bodyLen += 4 + len(bbp.hex)
	return bodyLen
}

func (bbp addr) MarshalBebop() []byte {
	buf := make([]byte, bbp.Size())
	bbp.MarshalBebopTo(buf)
	return buf
}

func makeaddr(r iohelp.ErrorReader) (addr, error) {
	v := addr{}
	err := v.DecodeBebop(r)
	return v, err
}

func makeaddrFromBytes(buf []byte) (addr, error) {
	v := addr{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

var _ bebop.Record = &log{}

type log struct {
	index   uint16
	address addr
	topics  []byte
	data    []byte
}

func (bbp log) MarshalBebopTo(buf []byte) int {
	at := 0
	iohelp.WriteUint16Bytes(buf[at:], bbp.index)
	at += 2
	(bbp.address).MarshalBebopTo(buf[at:])
	at += (bbp.address).Size()
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.topics)))
	at += 4
	copy(buf[at:at+len(bbp.topics)], bbp.topics)
	at += len(bbp.topics)
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.data)))
	at += 4
	copy(buf[at:at+len(bbp.data)], bbp.data)
	at += len(bbp.data)
	return at
}

func (bbp *log) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	if len(buf[at:]) < 2 {
		return io.ErrUnexpectedEOF
	}
	bbp.index = iohelp.ReadUint16Bytes(buf[at:])
	at += 2
	bbp.address, err = makeaddrFromBytes(buf[at:])
	if err != nil {
		return err
	}
	at += (bbp.address).Size()
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.topics = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.topics)*1 {
		return io.ErrUnexpectedEOF
	}
	copy(bbp.topics, buf[at:at+len(bbp.topics)])
	at += len(bbp.topics)
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.data = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.data)*1 {
		return io.ErrUnexpectedEOF
	}
	copy(bbp.data, buf[at:at+len(bbp.data)])
	at += len(bbp.data)
	return nil
}

func (bbp log) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint16(w, bbp.index)
	err = (bbp.address).EncodeBebop(w)
	if err != nil {
		return err
	}
	iohelp.WriteUint32(w, uint32(len(bbp.topics)))
	for _, elem := range bbp.topics {
		iohelp.WriteByte(w, elem)
	}
	iohelp.WriteUint32(w, uint32(len(bbp.data)))
	for _, elem := range bbp.data {
		iohelp.WriteByte(w, elem)
	}
	return w.Err
}

func (bbp *log) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.index = iohelp.ReadUint16(r)
	(bbp.address), err = makeaddr(r)
	if err != nil {
		return err
	}
	bbp.topics = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.topics {
		(bbp.topics[i1]) = iohelp.ReadByte(r)
	}
	bbp.data = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.data {
		(bbp.data[i1]) = iohelp.ReadByte(r)
	}
	return r.Err
}

func (bbp log) Size() int {
	bodyLen := 0
	bodyLen += 2
	bodyLen += (bbp.address).Size()
	bodyLen += 4
	bodyLen += len(bbp.topics) * 1
	bodyLen += 4
	bodyLen += len(bbp.data) * 1
	return bodyLen
}

func (bbp log) MarshalBebop() []byte {
	buf := make([]byte, bbp.Size())
	bbp.MarshalBebopTo(buf)
	return buf
}

func makelog(r iohelp.ErrorReader) (log, error) {
	v := log{}
	err := v.DecodeBebop(r)
	return v, err
}

func makelogFromBytes(buf []byte) (log, error) {
	v := log{}
	err := v.UnmarshalBebop(buf)
	return v, err
}
