// Code generated by bebopc-go; DO NOT EDIT.

package hmybebop

import (
	"github.com/200sc/bebop"
	"github.com/200sc/bebop/iohelp"
	"io"
)

var _ bebop.Record = &Transaction{}

type Transaction struct {
	Hash      []byte
	EthHash   []byte
	Sender    Addr
	Receiver  Addr
	BlockNum  uint32
	TimeStamp uint64
	Amount    []byte
	Input     []byte
	Method    Method
	Logs      []Log
	Status    byte
	GasAmount uint32
	GasPrice  []byte
	Shard     byte
	ToShard   byte
}

func (bbp Transaction) MarshalBebopTo(buf []byte) int {
	at := 0
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.Hash)))
	at += 4
	copy(buf[at:at+len(bbp.Hash)], bbp.Hash)
	at += len(bbp.Hash)
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.EthHash)))
	at += 4
	copy(buf[at:at+len(bbp.EthHash)], bbp.EthHash)
	at += len(bbp.EthHash)
	(bbp.Sender).MarshalBebopTo(buf[at:])
	at += (bbp.Sender).Size()
	(bbp.Receiver).MarshalBebopTo(buf[at:])
	at += (bbp.Receiver).Size()
	iohelp.WriteUint32Bytes(buf[at:], bbp.BlockNum)
	at += 4
	iohelp.WriteUint64Bytes(buf[at:], bbp.TimeStamp)
	at += 8
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.Amount)))
	at += 4
	copy(buf[at:at+len(bbp.Amount)], bbp.Amount)
	at += len(bbp.Amount)
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.Input)))
	at += 4
	copy(buf[at:at+len(bbp.Input)], bbp.Input)
	at += len(bbp.Input)
	(bbp.Method).MarshalBebopTo(buf[at:])
	at += (bbp.Method).Size()
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.Logs)))
	at += 4
	for _, v1 := range bbp.Logs {
		(v1).MarshalBebopTo(buf[at:])
		at += (v1).Size()
	}
	iohelp.WriteByteBytes(buf[at:], bbp.Status)
	at += 1
	iohelp.WriteUint32Bytes(buf[at:], bbp.GasAmount)
	at += 4
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.GasPrice)))
	at += 4
	copy(buf[at:at+len(bbp.GasPrice)], bbp.GasPrice)
	at += len(bbp.GasPrice)
	iohelp.WriteByteBytes(buf[at:], bbp.Shard)
	at += 1
	iohelp.WriteByteBytes(buf[at:], bbp.ToShard)
	at += 1
	return at
}

func (bbp *Transaction) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.Hash = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.Hash)*1 {
		return io.ErrUnexpectedEOF
	}
	copy(bbp.Hash, buf[at:at+len(bbp.Hash)])
	at += len(bbp.Hash)
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.EthHash = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.EthHash)*1 {
		return io.ErrUnexpectedEOF
	}
	copy(bbp.EthHash, buf[at:at+len(bbp.EthHash)])
	at += len(bbp.EthHash)
	bbp.Sender, err = MakeAddrFromBytes(buf[at:])
	if err != nil {
		return err
	}
	at += (bbp.Sender).Size()
	bbp.Receiver, err = MakeAddrFromBytes(buf[at:])
	if err != nil {
		return err
	}
	at += (bbp.Receiver).Size()
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.BlockNum = iohelp.ReadUint32Bytes(buf[at:])
	at += 4
	if len(buf[at:]) < 8 {
		return io.ErrUnexpectedEOF
	}
	bbp.TimeStamp = iohelp.ReadUint64Bytes(buf[at:])
	at += 8
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.Amount = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.Amount)*1 {
		return io.ErrUnexpectedEOF
	}
	copy(bbp.Amount, buf[at:at+len(bbp.Amount)])
	at += len(bbp.Amount)
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.Input = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.Input)*1 {
		return io.ErrUnexpectedEOF
	}
	copy(bbp.Input, buf[at:at+len(bbp.Input)])
	at += len(bbp.Input)
	bbp.Method, err = MakeMethodFromBytes(buf[at:])
	if err != nil {
		return err
	}
	at += (bbp.Method).Size()
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.Logs = make([]Log, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.Logs {
		(bbp.Logs)[i1], err = MakeLogFromBytes(buf[at:])
		if err != nil {
			return err
		}
		at += ((bbp.Logs)[i1]).Size()
	}
	if len(buf[at:]) < 1 {
		return io.ErrUnexpectedEOF
	}
	bbp.Status = iohelp.ReadByteBytes(buf[at:])
	at += 1
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.GasAmount = iohelp.ReadUint32Bytes(buf[at:])
	at += 4
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.GasPrice = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.GasPrice)*1 {
		return io.ErrUnexpectedEOF
	}
	copy(bbp.GasPrice, buf[at:at+len(bbp.GasPrice)])
	at += len(bbp.GasPrice)
	if len(buf[at:]) < 1 {
		return io.ErrUnexpectedEOF
	}
	bbp.Shard = iohelp.ReadByteBytes(buf[at:])
	at += 1
	if len(buf[at:]) < 1 {
		return io.ErrUnexpectedEOF
	}
	bbp.ToShard = iohelp.ReadByteBytes(buf[at:])
	at += 1
	return nil
}

func (bbp Transaction) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(len(bbp.Hash)))
	for _, elem := range bbp.Hash {
		iohelp.WriteByte(w, elem)
	}
	iohelp.WriteUint32(w, uint32(len(bbp.EthHash)))
	for _, elem := range bbp.EthHash {
		iohelp.WriteByte(w, elem)
	}
	err = (bbp.Sender).EncodeBebop(w)
	if err != nil {
		return err
	}
	err = (bbp.Receiver).EncodeBebop(w)
	if err != nil {
		return err
	}
	iohelp.WriteUint32(w, bbp.BlockNum)
	iohelp.WriteUint64(w, bbp.TimeStamp)
	iohelp.WriteUint32(w, uint32(len(bbp.Amount)))
	for _, elem := range bbp.Amount {
		iohelp.WriteByte(w, elem)
	}
	iohelp.WriteUint32(w, uint32(len(bbp.Input)))
	for _, elem := range bbp.Input {
		iohelp.WriteByte(w, elem)
	}
	err = (bbp.Method).EncodeBebop(w)
	if err != nil {
		return err
	}
	iohelp.WriteUint32(w, uint32(len(bbp.Logs)))
	for _, elem := range bbp.Logs {
		err = (elem).EncodeBebop(w)
		if err != nil {
			return err
		}
	}
	iohelp.WriteByte(w, bbp.Status)
	iohelp.WriteUint32(w, bbp.GasAmount)
	iohelp.WriteUint32(w, uint32(len(bbp.GasPrice)))
	for _, elem := range bbp.GasPrice {
		iohelp.WriteByte(w, elem)
	}
	iohelp.WriteByte(w, bbp.Shard)
	iohelp.WriteByte(w, bbp.ToShard)
	return w.Err
}

func (bbp *Transaction) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.Hash = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.Hash {
		(bbp.Hash[i1]) = iohelp.ReadByte(r)
	}
	bbp.EthHash = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.EthHash {
		(bbp.EthHash[i1]) = iohelp.ReadByte(r)
	}
	(bbp.Sender), err = MakeAddr(r)
	if err != nil {
		return err
	}
	(bbp.Receiver), err = MakeAddr(r)
	if err != nil {
		return err
	}
	bbp.BlockNum = iohelp.ReadUint32(r)
	bbp.TimeStamp = iohelp.ReadUint64(r)
	bbp.Amount = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.Amount {
		(bbp.Amount[i1]) = iohelp.ReadByte(r)
	}
	bbp.Input = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.Input {
		(bbp.Input[i1]) = iohelp.ReadByte(r)
	}
	(bbp.Method), err = MakeMethod(r)
	if err != nil {
		return err
	}
	bbp.Logs = make([]Log, iohelp.ReadUint32(r))
	for i1 := range bbp.Logs {
		(bbp.Logs[i1]), err = MakeLog(r)
		if err != nil {
			return err
		}
	}
	bbp.Status = iohelp.ReadByte(r)
	bbp.GasAmount = iohelp.ReadUint32(r)
	bbp.GasPrice = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.GasPrice {
		(bbp.GasPrice[i1]) = iohelp.ReadByte(r)
	}
	bbp.Shard = iohelp.ReadByte(r)
	bbp.ToShard = iohelp.ReadByte(r)
	return r.Err
}

func (bbp Transaction) Size() int {
	bodyLen := 0
	bodyLen += 4
	bodyLen += len(bbp.Hash) * 1
	bodyLen += 4
	bodyLen += len(bbp.EthHash) * 1
	bodyLen += (bbp.Sender).Size()
	bodyLen += (bbp.Receiver).Size()
	bodyLen += 4
	bodyLen += 8
	bodyLen += 4
	bodyLen += len(bbp.Amount) * 1
	bodyLen += 4
	bodyLen += len(bbp.Input) * 1
	bodyLen += (bbp.Method).Size()
	bodyLen += 4
	for _, elem := range bbp.Logs {
		bodyLen += (elem).Size()
	}
	bodyLen += 1
	bodyLen += 4
	bodyLen += 4
	bodyLen += len(bbp.GasPrice) * 1
	bodyLen += 1
	bodyLen += 1
	return bodyLen
}

func (bbp Transaction) MarshalBebop() []byte {
	buf := make([]byte, bbp.Size())
	bbp.MarshalBebopTo(buf)
	return buf
}

func MakeTransaction(r iohelp.ErrorReader) (Transaction, error) {
	v := Transaction{}
	err := v.DecodeBebop(r)
	return v, err
}

func MakeTransactionFromBytes(buf []byte) (Transaction, error) {
	v := Transaction{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

var _ bebop.Record = &Method{}

type Method struct {
	Signature string
	Name      string
	Params    []string
}

func (bbp Method) MarshalBebopTo(buf []byte) int {
	at := 0
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.Signature)))
	copy(buf[at+4:at+4+len(bbp.Signature)], []byte(bbp.Signature))
	at += 4 + len(bbp.Signature)
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.Name)))
	copy(buf[at+4:at+4+len(bbp.Name)], []byte(bbp.Name))
	at += 4 + len(bbp.Name)
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.Params)))
	at += 4
	for _, v1 := range bbp.Params {
		iohelp.WriteUint32Bytes(buf[at:], uint32(len(v1)))
		copy(buf[at+4:at+4+len(v1)], []byte(v1))
		at += 4 + len(v1)
	}
	return at
}

func (bbp *Method) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	bbp.Signature, err = iohelp.ReadStringBytes(buf[at:])
	if err != nil {
		return err
	}
	at += 4 + len(bbp.Signature)
	bbp.Name, err = iohelp.ReadStringBytes(buf[at:])
	if err != nil {
		return err
	}
	at += 4 + len(bbp.Name)
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.Params = make([]string, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	for i1 := range bbp.Params {
		(bbp.Params)[i1], err = iohelp.ReadStringBytes(buf[at:])
		if err != nil {
			return err
		}
		at += 4 + len((bbp.Params)[i1])
	}
	return nil
}

func (bbp Method) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(len(bbp.Signature)))
	w.Write([]byte(bbp.Signature))
	iohelp.WriteUint32(w, uint32(len(bbp.Name)))
	w.Write([]byte(bbp.Name))
	iohelp.WriteUint32(w, uint32(len(bbp.Params)))
	for _, elem := range bbp.Params {
		iohelp.WriteUint32(w, uint32(len(elem)))
		w.Write([]byte(elem))
	}
	return w.Err
}

func (bbp *Method) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.Signature = iohelp.ReadString(r)
	bbp.Name = iohelp.ReadString(r)
	bbp.Params = make([]string, iohelp.ReadUint32(r))
	for i1 := range bbp.Params {
		(bbp.Params[i1]) = iohelp.ReadString(r)
	}
	return r.Err
}

func (bbp Method) Size() int {
	bodyLen := 0
	bodyLen += 4 + len(bbp.Signature)
	bodyLen += 4 + len(bbp.Name)
	bodyLen += 4
	for _, elem := range bbp.Params {
		bodyLen += 4 + len(elem)
	}
	return bodyLen
}

func (bbp Method) MarshalBebop() []byte {
	buf := make([]byte, bbp.Size())
	bbp.MarshalBebopTo(buf)
	return buf
}

func MakeMethod(r iohelp.ErrorReader) (Method, error) {
	v := Method{}
	err := v.DecodeBebop(r)
	return v, err
}

func MakeMethodFromBytes(buf []byte) (Method, error) {
	v := Method{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

var _ bebop.Record = &Addr{}

type Addr struct {
	One string
	Hex string
}

func (bbp Addr) MarshalBebopTo(buf []byte) int {
	at := 0
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.One)))
	copy(buf[at+4:at+4+len(bbp.One)], []byte(bbp.One))
	at += 4 + len(bbp.One)
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.Hex)))
	copy(buf[at+4:at+4+len(bbp.Hex)], []byte(bbp.Hex))
	at += 4 + len(bbp.Hex)
	return at
}

func (bbp *Addr) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	bbp.One, err = iohelp.ReadStringBytes(buf[at:])
	if err != nil {
		return err
	}
	at += 4 + len(bbp.One)
	bbp.Hex, err = iohelp.ReadStringBytes(buf[at:])
	if err != nil {
		return err
	}
	at += 4 + len(bbp.Hex)
	return nil
}

func (bbp Addr) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint32(w, uint32(len(bbp.One)))
	w.Write([]byte(bbp.One))
	iohelp.WriteUint32(w, uint32(len(bbp.Hex)))
	w.Write([]byte(bbp.Hex))
	return w.Err
}

func (bbp *Addr) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.One = iohelp.ReadString(r)
	bbp.Hex = iohelp.ReadString(r)
	return r.Err
}

func (bbp Addr) Size() int {
	bodyLen := 0
	bodyLen += 4 + len(bbp.One)
	bodyLen += 4 + len(bbp.Hex)
	return bodyLen
}

func (bbp Addr) MarshalBebop() []byte {
	buf := make([]byte, bbp.Size())
	bbp.MarshalBebopTo(buf)
	return buf
}

func MakeAddr(r iohelp.ErrorReader) (Addr, error) {
	v := Addr{}
	err := v.DecodeBebop(r)
	return v, err
}

func MakeAddrFromBytes(buf []byte) (Addr, error) {
	v := Addr{}
	err := v.UnmarshalBebop(buf)
	return v, err
}

var _ bebop.Record = &Log{}

type Log struct {
	Index   uint16
	Address Addr
	Topics  []byte
	Data    []byte
}

func (bbp Log) MarshalBebopTo(buf []byte) int {
	at := 0
	iohelp.WriteUint16Bytes(buf[at:], bbp.Index)
	at += 2
	(bbp.Address).MarshalBebopTo(buf[at:])
	at += (bbp.Address).Size()
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.Topics)))
	at += 4
	copy(buf[at:at+len(bbp.Topics)], bbp.Topics)
	at += len(bbp.Topics)
	iohelp.WriteUint32Bytes(buf[at:], uint32(len(bbp.Data)))
	at += 4
	copy(buf[at:at+len(bbp.Data)], bbp.Data)
	at += len(bbp.Data)
	return at
}

func (bbp *Log) UnmarshalBebop(buf []byte) (err error) {
	at := 0
	if len(buf[at:]) < 2 {
		return io.ErrUnexpectedEOF
	}
	bbp.Index = iohelp.ReadUint16Bytes(buf[at:])
	at += 2
	bbp.Address, err = MakeAddrFromBytes(buf[at:])
	if err != nil {
		return err
	}
	at += (bbp.Address).Size()
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.Topics = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.Topics)*1 {
		return io.ErrUnexpectedEOF
	}
	copy(bbp.Topics, buf[at:at+len(bbp.Topics)])
	at += len(bbp.Topics)
	if len(buf[at:]) < 4 {
		return io.ErrUnexpectedEOF
	}
	bbp.Data = make([]byte, iohelp.ReadUint32Bytes(buf[at:]))
	at += 4
	if len(buf[at:]) < len(bbp.Data)*1 {
		return io.ErrUnexpectedEOF
	}
	copy(bbp.Data, buf[at:at+len(bbp.Data)])
	at += len(bbp.Data)
	return nil
}

func (bbp Log) EncodeBebop(iow io.Writer) (err error) {
	w := iohelp.NewErrorWriter(iow)
	iohelp.WriteUint16(w, bbp.Index)
	err = (bbp.Address).EncodeBebop(w)
	if err != nil {
		return err
	}
	iohelp.WriteUint32(w, uint32(len(bbp.Topics)))
	for _, elem := range bbp.Topics {
		iohelp.WriteByte(w, elem)
	}
	iohelp.WriteUint32(w, uint32(len(bbp.Data)))
	for _, elem := range bbp.Data {
		iohelp.WriteByte(w, elem)
	}
	return w.Err
}

func (bbp *Log) DecodeBebop(ior io.Reader) (err error) {
	r := iohelp.NewErrorReader(ior)
	bbp.Index = iohelp.ReadUint16(r)
	(bbp.Address), err = MakeAddr(r)
	if err != nil {
		return err
	}
	bbp.Topics = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.Topics {
		(bbp.Topics[i1]) = iohelp.ReadByte(r)
	}
	bbp.Data = make([]byte, iohelp.ReadUint32(r))
	for i1 := range bbp.Data {
		(bbp.Data[i1]) = iohelp.ReadByte(r)
	}
	return r.Err
}

func (bbp Log) Size() int {
	bodyLen := 0
	bodyLen += 2
	bodyLen += (bbp.Address).Size()
	bodyLen += 4
	bodyLen += len(bbp.Topics) * 1
	bodyLen += 4
	bodyLen += len(bbp.Data) * 1
	return bodyLen
}

func (bbp Log) MarshalBebop() []byte {
	buf := make([]byte, bbp.Size())
	bbp.MarshalBebopTo(buf)
	return buf
}

func MakeLog(r iohelp.ErrorReader) (Log, error) {
	v := Log{}
	err := v.DecodeBebop(r)
	return v, err
}

func MakeLogFromBytes(buf []byte) (Log, error) {
	v := Log{}
	err := v.UnmarshalBebop(buf)
	return v, err
}
