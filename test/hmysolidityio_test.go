package test

import (
	"encoding/hex"
	"fmt"
	"github.com/go-errors/errors"
	"github.com/mjmar01/harmolytics/pkg/hmysolidityio"
	"github.com/mjmar01/harmolytics/pkg/types"
	"math/big"
	"testing"
)

const (
	testSwapInput = "0x8803dbee000000000000000000000000000000000000000000000000000000000000002a000000000000000000000000000000000000000000000000000000000000002a00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000a33f8390105ecbdfa309d64b569806d11f596200000000000000000000000000000000000000000000000000000000006081cd0f0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000ea589e93ff18b1a1f1e9bac7ef3e86ab62addc7900000000000000000000000058f1b044d8308812881a1433d9bbeff99975e70c"
	testString    = "000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000074869206d6f6d2100000000000000000000000000000000000000000000000000"
)

func TestDecodeAddress(t *testing.T) {
	a, err := hmysolidityio.DecodeAddress(testSwapInput, 3)
	if err != nil {
		t.Fatal(err.(*errors.Error).ErrorStack())
	}

	if a.OneAddress != "one15vlc8yqstm9algcf6e94dxqx6y04jcsqjuc3gt" {
		t.Errorf("Output does not have expected address: %s", a.OneAddress)
	}
}

func TestDecodeInt(t *testing.T) {
	i1, err := hmysolidityio.DecodeInt(testSwapInput, 0)
	if err != nil {
		t.Fatal(err.(*errors.Error).ErrorStack())
	}
	i2, err := hmysolidityio.DecodeInt(testSwapInput, 1)
	if err != nil {
		t.Fatal(err.(*errors.Error).ErrorStack())
	}

	if i1.Int64() != 42 {
		t.Errorf("Output for position 0 did contain incorrect value: %d", i1)
	}
	if i2.Int64() != 42 {
		t.Errorf("Output for position 1 did contain incorrect value: %d", i2)
	}
}

func TestDecodeString(t *testing.T) {
	s, err := hmysolidityio.DecodeString(testString, 0)
	if err != nil {
		t.Fatal(err.(*errors.Error).ErrorStack())
	}

	if s != "Hi mom!" {
		t.Errorf("Output did contain incorrect string: %s", s)
	}
}

func TestDecodeArray(t *testing.T) {
	arr, err := hmysolidityio.DecodeArray(testSwapInput, 2)
	if err != nil {
		t.Fatal(err.(*errors.Error).ErrorStack())
	}
	addr, err := hmysolidityio.DecodeAddress(hex.EncodeToString(arr[0]), 0)
	if err != nil {
		t.Fatal(err.(*errors.Error).ErrorStack())
	}

	if len(arr) != 2 {
		t.Errorf("Output slice has incorrect length: %d", len(arr))
	}
	if addr.OneAddress != "one1afvfayllrzc6ru0fhtr7705x4d32mhrewz4c77" {
		t.Errorf("Output did contain incorrect value for address 0: %s", addr.OneAddress)
	}
}

func TestEncodeAll(t *testing.T) {
	i := new(big.Int)
	i.SetInt64(17)
	addr := types.NewAddress("one1afvfayllrzc6ru0fhtr7705x4d32mhrewz4c77")
	s, err := hmysolidityio.EncodeAll(
		i,    // 0
		addr, // 1
		"Looooooooooooooooooooooooooooooooooooooooooooong test", // 2
		"Short test", // 3
		[]interface{}{ // 4
			addr,
			addr,
		},
		[]interface{}{ // 5
			[]interface{}{
				"I love recursion!",
				"Inception!!!",
			},
		},
		"~FIN~", // 6
	)
	if err != nil {
		t.Fatal(err.(*errors.Error).ErrorStack())
	}

	if s != "0000000000000000000000000000000000000000000000000000000000000011000000000000000000000000ea589e93ff18b1a1f1e9bac7ef3e86ab62addc7900000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000022000000000000000000000000000000000000000000000000000000000000000354c6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6f6e6720746573740000000000000000000000000000000000000000000000000000000000000000000000000000000000000a53686f72742074657374000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000ea589e93ff18b1a1f1e9bac7ef3e86ab62addc79000000000000000000000000ea589e93ff18b1a1f1e9bac7ef3e86ab62addc790000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000026000000000000000000000000000000000000000000000000000000000000000057e46494e7e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000002c00000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000001149206c6f766520726563757273696f6e21000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c496e63657074696f6e2121210000000000000000000000000000000000000000" {
		readHelper := ""
		for {
			readHelper += fmt.Sprintf("%s\n", s[:64])
			s = s[64:]
			if len(s) == 0 {
				break
			}
		}
		t.Errorf("Output string is incorrect:\n%s", readHelper)
	}
}
