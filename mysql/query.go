package mysql

import (
	"database/sql"
	"fmt"
	"github.com/go-errors/errors"
	"harmolytics/harmony"
	"harmolytics/harmony/address"
	"math/big"
	"strings"
)

const (
	tokenQuery                  = "SELECT address, symbol, name, decimals FROM harmolytics_%s.tokens"
	transactionLogsHashQuery    = "SELECT hash, topics, address, data, logIndex FROM harmolytics_%s.transaction_logs WHERE hash = '%s'"
	transactionLogsTypeQuery    = "SELECT hash, topics, address, data, logIndex FROM harmolytics_%s.transaction_logs WHERE topics LIKE '%s%%'"
	transactionsMethodNameQuery = "SELECT hash, sender, receiver, input, method, unixtime, blockNum, gasAmount, gasPrice, value, shardID, toShardID FROM harmolytics_%s.transactions WHERE method IN (SELECT signature FROM harmolytics_default.methods WHERE name LIKE '%s') ORDER BY blockNum ASC"
	transactionsLogIdQuery      = "SELECT hash, sender, receiver, input, method, unixtime, blockNum, gasAmount, gasPrice, value, shardID, toShardID FROM harmolytics_%s.transactions WHERE hash IN (SELECT hash FROM harmolytics_%s.transaction_logs WHERE topics LIKE '%s%%')"
	methodQuery                 = "SELECT signature, name, parameters FROM harmolytics_default.methods WHERE signature = '%s'"
)

// RunTemplate executes a list of queries usually generated by a text/template.
func RunTemplate(queries string) (err error) {
	for _, query := range strings.Split(strings.TrimRight(queries, " ;\n\t"), ";") {
		rows, err := db.Query(query)
		if err != nil {
			return errors.Wrap(err, 0)
		}
		err = rows.Close()
		if err != nil {
			return errors.Wrap(err, 0)
		}
	}
	return
}

// GetStringsByQuery takes a query that returns a single column and returns the rows as a list of strings.
func GetStringsByQuery(query string) (r []string, err error) {
	rows, err := db.Query(query)
	defer rows.Close()
	if err != nil {
		return nil, errors.Wrap(err, 0)
	}
	for rows.Next() {
		var s string
		err := rows.Scan(&s)
		if err != nil {
			return nil, errors.Wrap(err, 0)
		}
		r = append(r, s)
	}
	return
}

// GetStringByQuery takes a query that returns a single column and row and returns this value as string.
func GetStringByQuery(query string) (s string, err error) {
	rows, err := db.Query(query)
	defer rows.Close()
	if err != nil {
		return "", errors.Wrap(err, 0)
	}
	rows.Next()
	err = rows.Scan(&s)
	if err != nil {
		return "", errors.Wrap(err, 0)
	}
	return
}

// GetTokens returns all tokens from the databse
func GetTokens() (tokens []harmony.Token, err error) {
	rows, err := db.Query(fmt.Sprintf(tokenQuery, profile))
	defer rows.Close()
	if err != nil {
		return nil, errors.Wrap(err, 0)
	}
	for rows.Next() {
		var t harmony.Token
		var addr string
		err = rows.Scan(&addr, &t.Symbol, &t.Name, &t.Decimals)
		if err != nil {
			return nil, errors.Wrap(err, 0)
		}
		t.Address, err = address.New(addr)
		if err != nil {
			return
		}
		tokens = append(tokens, t)
	}
	return
}

func GetTransactionsByMethodName(name string) (txs []harmony.Transaction, err error) {
	rows, err := db.Query(fmt.Sprintf(transactionsMethodNameQuery, profile, name))
	defer rows.Close()
	if err != nil {
		return nil, errors.Wrap(err, 0)
	}
	txs, err = getTransactionsFromResult(rows)
	if err != nil {
		return
	}
	return
}

func GetTransactionsByLogId(id string) (txs []harmony.Transaction, err error) {
	rows, err := db.Query(fmt.Sprintf(transactionsLogIdQuery, profile, profile, id))
	defer rows.Close()
	if err != nil {
		return nil, errors.Wrap(err, 0)
	}
	txs, err = getTransactionsFromResult(rows)
	if err != nil {
		return
	}
	return
}

// GetTransactionLogsByHash returns a list of transaction.Log for a given transaction hash.
func GetTransactionLogsByHash(txHash string) (logs []harmony.TransactionLog, err error) {
	rows, err := db.Query(fmt.Sprintf(transactionLogsHashQuery, profile, txHash))
	defer rows.Close()
	if err != nil {
		return nil, errors.Wrap(err, 0)
	}
	for rows.Next() {
		var l harmony.TransactionLog
		var topics, addr string
		err = rows.Scan(&l.TxHash, &topics, &addr, &l.Data, &l.LogIndex)
		if err != nil {
			return nil, errors.Wrap(err, 0)
		}
		l.Topics = strings.Split(topics, ":")
		l.Address, err = address.New(addr)
		if err != nil {
			return
		}
		logs = append(logs, l)
	}
	return
}

func GetTransactionLogByType(id string) (logs []harmony.TransactionLog) {
	rows, err := db.Query(fmt.Sprintf(transactionLogsTypeQuery, profile, id))
	defer rows.Close()
	if err != nil {
		return nil
	}
	for rows.Next() {
		var l harmony.TransactionLog
		var topics, addr string
		err := rows.Scan(&l.TxHash, &topics, &addr, &l.Data, &l.LogIndex)
		if err != nil {
			return nil
		}
		l.Topics = strings.Split(topics, ":")
		l.Address, err = address.New(addr)
		if err != nil {
			return nil
		}
		logs = append(logs, l)
	}
	return logs
}

func GetMethodBySignature(sig string) (m harmony.Method, err error) {
	rows, err := db.Query(fmt.Sprintf(methodQuery, sig))
	defer rows.Close()
	if err != nil {
		return harmony.Method{}, errors.Wrap(err, 0)
	}
	if !(rows.Next()) {
		return harmony.Method{Signature: sig}, nil
	}
	var p string
	err = rows.Scan(&m.Signature, &m.Name, &p)
	if err != nil {
		return harmony.Method{}, errors.Wrap(err, 0)
	}
	m.Parameters = strings.Split(p, ":")
	return
}

func getTransactionsFromResult(rows *sql.Rows) (txs []harmony.Transaction, err error) {
	for rows.Next() {
		var tx harmony.Transaction
		var s, r, m, v, g string
		err = rows.Scan(&tx.TxHash, &s, &r, &tx.Input, &m, &tx.Timestamp, &tx.BlockNum, &tx.GasAmount, &g, &v, &tx.ShardID, &tx.ToShardID)
		if err != nil {
			return nil, errors.Wrap(err, 0)
		}
		tx.Sender, err = address.New(s)
		if err != nil {
			return
		}
		tx.Receiver, err = address.New(r)
		if err != nil {
			return
		}
		if m != "" {
			tx.Method, err = GetMethodBySignature(m)
		}
		if err != nil {
			return
		}
		tx.Logs, err = GetTransactionLogsByHash(tx.TxHash)
		if err != nil {
			return
		}
		tx.Value, tx.GasPrice = new(big.Int), new(big.Int)
		tx.Value.SetString(v, 10)
		tx.GasPrice.SetString(g, 10)
		txs = append(txs, tx)
	}
	return
}
