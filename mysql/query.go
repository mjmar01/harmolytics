package mysql

import (
	"database/sql"
	"fmt"
	"github.com/go-errors/errors"
	"harmolytics/harmony"
	"harmolytics/harmony/address"
	"math/big"
	"strings"
)

const (
	tokenQuery                  = "SELECT address, symbol, name, decimals FROM harmolytics_default.tokens"
	swapsQuery                  = "SELECT hash, input_token, output_token, input_amount, output_amount, path FROM harmolytics_profile_%s.swaps"
	ratiosQuery                 = "SELECT liquidity_pool, block_num, reserve_a, reserve_b FROM harmolytics_historic.liquidity_ratios"
	liquidityPoolQuery          = "SELECT token_a, token_b FROM harmolytics_default.liquidity_pools WHERE address = '%s'"
	blockQuery                  = "SELECT block_num FROM harmolytics_profile_%s.transactions WHERE hash = '%s'"
	transactionLogsHashQuery    = "SELECT hash, topics, address, data, log_index FROM harmolytics_profile_%s.transaction_logs WHERE hash = '%s'"
	transactionLogsTypeQuery    = "SELECT hash, topics, address, data, log_index FROM harmolytics_profile_%s.transaction_logs WHERE topics LIKE '%s%%'"
	transactionsMethodNameQuery = "SELECT hash, sender, receiver, input, method_signature, unixtime, block_num, gas_amount, gas_price, value, shard_id, to_shard_id FROM harmolytics_profile_%s.transactions WHERE method_signature IN (SELECT signature FROM harmolytics_default.methods WHERE name LIKE '%s') ORDER BY block_num ASC"
	transactionsLogIdQuery      = "SELECT hash, sender, receiver, input, method_signature, unixtime, block_num, gas_amount, gas_price, value, shard_id, to_shard_id FROM harmolytics_profile_%s.transactions WHERE hash IN (SELECT hash FROM harmolytics_profile_%s.transaction_logs WHERE topics LIKE '%s%%')"
	transactionHashQuery        = "SELECT hash, sender, receiver, input, method_signature, unixtime, block_num, gas_amount, gas_price, value, shard_id, to_shard_id FROM harmolytics_profile_%s.transactions WHERE hash = '%s'"
	methodQuery                 = "SELECT signature, name, parameters FROM harmolytics_default.methods WHERE signature = '%s'"
)

// RunTemplate executes a list of queries usually generated by a text/template.
func RunTemplate(queries string) (err error) {
	for _, query := range strings.Split(strings.TrimRight(queries, " ;\n\t"), ";") {
		if query == "" {
			continue
		}
		rows, err := db.Query(query)
		if err != nil {
			fmt.Println(query)
			return errors.Wrap(err, 0)
		}
		err = rows.Close()
		if err != nil {
			return errors.Wrap(err, 0)
		}
	}
	return
}

func RunQuery(query string) (err error) {
	rows, err := db.Query(query)
	if err != nil {
		return errors.Wrap(err, 0)
	}
	err = rows.Close()
	if err != nil {
		return errors.Wrap(err, 0)
	}
	return
}

// GetStringsByQuery takes a query that returns a single column and returns the rows as a list of strings.
func GetStringsByQuery(query string) (r []string, err error) {
	rows, err := db.Query(query)
	defer rows.Close()
	if err != nil {
		return nil, errors.Wrap(err, 0)
	}
	for rows.Next() {
		var s string
		err := rows.Scan(&s)
		if err != nil {
			return nil, errors.Wrap(err, 0)
		}
		r = append(r, s)
	}
	return
}

// GetStringByQuery takes a query that returns a single column and row and returns this value as string.
func GetStringByQuery(query string) (s string, err error) {
	rows, err := db.Query(query)
	defer rows.Close()
	if err != nil {
		return "", errors.Wrap(err, 0)
	}
	rows.Next()
	err = rows.Scan(&s)
	if err != nil {
		return "", errors.Wrap(err, 0)
	}
	return
}

// GetTokens returns all tokens from the databse
func GetTokens() (tokens []harmony.Token, err error) {
	rows, err := db.Query(tokenQuery)
	defer rows.Close()
	if err != nil {
		return nil, errors.Wrap(err, 0)
	}
	for rows.Next() {
		var t harmony.Token
		var addr string
		err = rows.Scan(&addr, &t.Symbol, &t.Name, &t.Decimals)
		if err != nil {
			return nil, errors.Wrap(err, 0)
		}
		t.Address, err = address.New(addr)
		if err != nil {
			return
		}
		tokens = append(tokens, t)
	}
	return
}

func GetTransactionsByMethodName(name string) (txs []harmony.Transaction, err error) {
	rows, err := db.Query(fmt.Sprintf(transactionsMethodNameQuery, profile, name))
	defer rows.Close()
	if err != nil {
		return nil, errors.Wrap(err, 0)
	}
	txs, err = getTransactionsFromResult(rows)
	if err != nil {
		return
	}
	return
}

func GetTransactionsByLogId(id string) (txs []harmony.Transaction, err error) {
	rows, err := db.Query(fmt.Sprintf(transactionsLogIdQuery, profile, profile, id))
	defer rows.Close()
	if err != nil {
		return nil, errors.Wrap(err, 0)
	}
	txs, err = getTransactionsFromResult(rows)
	if err != nil {
		return
	}
	return
}

func GetTransactionByHash(hash string) (tx harmony.Transaction, err error) {
	rows, err := db.Query(fmt.Sprintf(transactionHashQuery, profile, hash))
	defer rows.Close()
	if err != nil {
		return harmony.Transaction{}, errors.Wrap(err, 0)
	}
	txs, err := getTransactionsFromResult(rows)
	if err != nil {
		return
	}
	tx = txs[0]
	return
}

// GetTransactionLogsByHash returns a list of transaction.Log for a given transaction hash.
func GetTransactionLogsByHash(txHash string) (logs []harmony.TransactionLog, err error) {
	rows, err := db.Query(fmt.Sprintf(transactionLogsHashQuery, profile, txHash))
	defer rows.Close()
	if err != nil {
		return nil, errors.Wrap(err, 0)
	}
	for rows.Next() {
		var l harmony.TransactionLog
		var topics, addr string
		err = rows.Scan(&l.TxHash, &topics, &addr, &l.Data, &l.LogIndex)
		if err != nil {
			return nil, errors.Wrap(err, 0)
		}
		l.Topics = strings.Split(topics, ":")
		l.Address, err = address.New(addr)
		if err != nil {
			return
		}
		logs = append(logs, l)
	}
	return
}

func GetTransactionLogByType(id string) (logs []harmony.TransactionLog) {
	rows, err := db.Query(fmt.Sprintf(transactionLogsTypeQuery, profile, id))
	defer rows.Close()
	if err != nil {
		return nil
	}
	for rows.Next() {
		var l harmony.TransactionLog
		var topics, addr string
		err := rows.Scan(&l.TxHash, &topics, &addr, &l.Data, &l.LogIndex)
		if err != nil {
			return nil
		}
		l.Topics = strings.Split(topics, ":")
		l.Address, err = address.New(addr)
		if err != nil {
			return nil
		}
		logs = append(logs, l)
	}
	return logs
}

func GetMethodBySignature(sig string) (m harmony.Method, err error) {
	rows, err := db.Query(fmt.Sprintf(methodQuery, sig))
	defer rows.Close()
	if err != nil {
		return harmony.Method{}, errors.Wrap(err, 0)
	}
	if !(rows.Next()) {
		return harmony.Method{Signature: sig}, nil
	}
	var p string
	err = rows.Scan(&m.Signature, &m.Name, &p)
	if err != nil {
		return harmony.Method{}, errors.Wrap(err, 0)
	}
	m.Parameters = strings.Split(p, ":")
	return
}

func GetSwaps() (swaps []harmony.Swap, err error) {
	rows, err := db.Query(fmt.Sprintf(swapsQuery, profile))
	defer rows.Close()
	if err != nil {
		return nil, errors.Wrap(err, 0)
	}
	for rows.Next() {
		var s harmony.Swap
		var tokenA, tokenB, amountA, amountB, path string
		err = rows.Scan(&s.TxHash, &tokenA, &tokenB, &amountA, &amountB, &path)
		if err != nil {
			return nil, errors.Wrap(err, 0)
		}
		tokenAddress, err := address.New(tokenA)
		if err != nil {
			return nil, err
		}
		s.InToken = harmony.Token{Address: tokenAddress}
		tokenAddress, err = address.New(tokenB)
		if err != nil {
			return nil, err
		}
		s.OutToken = harmony.Token{Address: tokenAddress}
		s.InAmount = new(big.Int)
		s.OutAmount = new(big.Int)
		s.InAmount.SetString(amountA, 10)
		s.OutAmount.SetString(amountB, 10)
		for _, p := range strings.Split(path, ":") {
			lpAddr, err := address.New(p)
			if err != nil {
				return nil, err
			}
			s.Path = append(s.Path, harmony.LiquidityPool{LpToken: harmony.Token{Address: lpAddr}})
		}
		swaps = append(swaps, s)
	}
	return
}

func GetLiquidityPool(lpAddr string) (lp harmony.LiquidityPool, err error) {
	rows, err := db.Query(fmt.Sprintf(liquidityPoolQuery, lpAddr))
	defer rows.Close()
	if err != nil {
		return harmony.LiquidityPool{}, errors.Wrap(err, 0)
	}
	rows.Next()
	var a, b string
	err = rows.Scan(&a, &b)
	if err != nil {
		return harmony.LiquidityPool{}, errors.Wrap(err, 0)
	}
	tokenLP, err := address.New(lpAddr)
	if err != nil {
		return
	}
	tokenA, err := address.New(a)
	if err != nil {
		return
	}
	tokenB, err := address.New(b)
	if err != nil {
		return
	}
	lp.LpToken.Address = tokenLP
	lp.TokenA.Address = tokenA
	lp.TokenB.Address = tokenB
	return
}

func GetRatios() (ratios []harmony.HistoricLiquidityRatio, err error) {
	rows, err := db.Query(ratiosQuery)
	defer rows.Close()
	if err != nil {
		return nil, errors.Wrap(err, 0)
	}
	for rows.Next() {
		var r harmony.HistoricLiquidityRatio
		var lp, amountA, amountB string
		err = rows.Scan(&lp, &r.BlockNum, &amountA, &amountB)
		if err != nil {
			return nil, errors.Wrap(err, 0)
		}
		r.LP, err = GetLiquidityPool(lp)
		if err != nil {
			return
		}
		r.ReserveA = new(big.Int)
		r.ReserveB = new(big.Int)
		r.ReserveA.SetString(amountA, 10)
		r.ReserveB.SetString(amountB, 10)
		ratios = append(ratios, r)
	}
	return
}

func GetBlockByTx(tx string) (block uint64, err error) {
	rows, err := db.Query(fmt.Sprintf(blockQuery, profile, tx))
	defer rows.Close()
	if err != nil {
		return 0, errors.Wrap(err, 0)
	}
	rows.Next()
	err = rows.Scan(&block)
	if err != nil {
		return 0, errors.Wrap(err, 0)
	}
	return
}

func getTransactionsFromResult(rows *sql.Rows) (txs []harmony.Transaction, err error) {
	for rows.Next() {
		var tx harmony.Transaction
		var s, r, m, v, g string
		err = rows.Scan(&tx.TxHash, &s, &r, &tx.Input, &m, &tx.Timestamp, &tx.BlockNum, &tx.GasAmount, &g, &v, &tx.ShardID, &tx.ToShardID)
		if err != nil {
			return nil, errors.Wrap(err, 0)
		}
		tx.Sender, err = address.New(s)
		if err != nil {
			return
		}
		tx.Receiver, err = address.New(r)
		if err != nil {
			return
		}
		if m != "" {
			tx.Method, err = GetMethodBySignature(m)
		}
		if err != nil {
			return
		}
		tx.Logs, err = GetTransactionLogsByHash(tx.TxHash)
		if err != nil {
			return
		}
		tx.Value, tx.GasPrice = new(big.Int), new(big.Int)
		tx.Value.SetString(v, 10)
		tx.GasPrice.SetString(g, 10)
		txs = append(txs, tx)
	}
	return
}
